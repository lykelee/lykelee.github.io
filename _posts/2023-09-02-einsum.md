---
title: "아인슈타인 표기법과 einsum 함수"
categories:
  - Mathematics
  - Computer Science
tags:
  - NumPy
---

아인슈타인 표기법(Einstein notation)은 첨자가 있는 값들의 합을 편리하게 나타내는 표기 방법이다.
이 표기법에 따라 계산하는 함수인 `einsum`은 NumPy, PyTorch 등의 파이썬 라이브러리에서 지원한다. 이 함수를 사용하여 복잡한 연산을 간결하게 나타낼 수 있으며 상황에 따라 성능도 향상시킬 수 있다.

## 아인슈타인 표기법

아인슈타인 표기법을 만든 사람은 그 유명한 알베르트 아인슈타인(Albert Einstein)이다. 아인슈타인은 일반 상대성 이론에서 나오는 수많은 변수의 합을 간단히 표현하기 위해 이 표기법을 도입하였다. 이 표기법은 주로 물리학에서 사용되다가, 최근에는 머신러닝 등에서 복잡한 텐서 연산을 표현하기 위해 활용되기도 한다.

아인슈타인 표기법의 핵심은 합 기호($\sum$)를 제거하고 이것 없이도 원소들이 어떻게 더해지는지 추론할 수 있도록 하는 것이다. 다음 예를 살펴보자.

$$ c = \sum_{i=1}^n a_i b_i $$

$c$는 $a \cdot b$ (내적)이다. 여기서 합 기호를 제거하면

$$ c = a_i b_i $$

이다. 합 기호가 제거됨으로써, $a$와 $b$의 첨자인 $i$는 특정한 값이 부여되지 않는다. 고정되지 않은 첨자는 앞에 합 기호가 생략된 것으로 간주한다. 따라서 이 식으로부터 합 기호가 생략됨을 거꾸로 추론할 수 있다. 합의 범위는 첨자가 위치한 텐서의 크기에 의해 결정된다.

비슷하지만 다른 예시를 살펴보자.

$$ c_i = a_i b_i $$

이 경우 $i$는 $c$의 첨자로 고정된 것이다. $c_i$는 $c$의 각 $i$번째 원소를 뜻한다. 따라서 $c_i$의 값으로 설정되는 $a_i b_i$에서 $i$는 고정된 값이다. 결과적으로 $c$는 $a$, $b$와 차원이 같은 벡터이고, $a$와 $b$ 간의 성분별 곱과 같다.

텐서의 차원이 늘어나도 방법은 똑같다. 연산 결과에 부여된 첨자는 고정된 첨자이고, 부여되지 않은 첨자는 고정되지 않았으므로 합을 취한다. 예를 들어, 두 행렬 $A$, $B$의 곱은

$$ C_{ik} = A_{ij} B_{jk} $$

로 표현된다. 결과 텐서인 $C$의 첨자가 $i, k$이므로 이 값들은 고정되었고, $j$에 대해서는 합을 취한다. 즉

$$ C_{ik} = \sum_{j=1}^n A_{ij} B_{jk} $$

이다.

입력 텐서가 3개 이상이거나 동일한 첨자가 3번 이상 포함되는 것도 가능하다. 예를 들어, $d_{i} = a_{i} b_{i} c_{i}$는 세 벡터 $a$, $b$, $c$의 성분별 곱이다. 입력 텐서에 동일한 첨자가 여러 번 들어가는 것도 가능하다. 예를 들어, $b = A_{ii}$는 행렬 $A$의 대각합(trace)이다 (단 $A$는 정방행렬이어야 한다). 이 경우 $A$의 대각선 성분만이 계산에 사용된다. 단 $B_{ii} = a_i$와 같이 결과 텐서에는 첨자가 중복될 수 없다. 첨자가 중복으로 들어갈 경우 무시되는 성분이 생기는데, 입력 텐서의 경우 사용하지 않는 성분이 있어도 되지만 결과 텐서는 모든 성분이 명시적으로 설정되어야 하기 때문이다.

합을 제거하는 과정에서 의문이 들 수도 있다. 합이 여러 개인 경우 표기법으로부터 원래의 합 순서를 복원할 수 없기 때문이다. 그러나 합의 순서는 결과에 영향을 주지 않으므로 문제가 되지 않는다. 첨자에 대한 합은 순서를 바꾸어도 결과가 동일하기 때문이다. 즉

$$ \sum_{i=1}^m \sum_{j=1}^n f(i, j) = \sum_{j=1}^n \sum_{i=1}^m f(i, j) $$

가 성립하기 때문이다.

## `einsum` 함수

`einsum`은 여러 라이브러리에서 아인슈타인 표기법에 따라 계산하는 함수의 이름으로 사용된다. 여기서는 NumPy를 기준으로 할 것이다. 다른 라이브러리에서도 기본적인 사용법은 같을 것이나 세부 사항이 다를 수 있음에 주의하자.

NumPy의 `einsum`의 사용법은 다음과 같다.

$$ \mathrm{einsum}("[i_1], \; ... \; ,[i_n]->[output]", \; a_1, \; ..., \; a_n) $$

입력의 개수는 총 $n$개이고, $a_i$는 $i$번째 입력을 뜻한다. $[i_1]$는 $i$번째 입력의 첨자를 의미한다.

예를 들어, 행렬곱을 나타내는 $C_{ik} = A_{ij} B_{jk}$는 `einsum`으로

```python
np.einsum("ij,jk->ik", A, B)
```

로 표현된다.

NumPy의 `einsum` 함수는 타입 변환 방식, 최적화 방법 등 추가 설정을 할 수 있다. 자세한 내용은 [매뉴얼](https://numpy.org/doc/stable/reference/generated/numpy.einsum.html)에서 확인할 수 있다.

## 예시

[Tim Rocktäschel의 글](https://rockt.github.io/2018/04/30/einsum)에서 다양한 예시를 볼 수 있다.

### 항등 변환 (Identity)

입력과 출력의 첨자를 동일하게 설정한다. 아래는 하나의 차원을 가졌을 때의 예이다.

$$ b_i = a_i $$

```python
np.einsum("i->i", a)
```

### 성분의 합 (Sum of Entries)

출력의 첨자가 없도록 한다. 아래는 하나의 차원을 가졌을 때의 예이다.

$$ b = a_{i} $$

```python
np.einsum("i->", a)
```

### 성분별 곱 (Element-wise Product)

두 입력과 출력의 첨자를 동일하게 설정한다. 아래는 하나의 차원을 가졌을 때의 예이다.

$$ c_{i} = a_{i} b_{i} $$

```python
np.einsum("i,i->i", a, b)
```

### 전치 (Transpose)

$$ B_{ij} = A_{ji} $$

```python
np.einsum("ji->ij", A)
```

### 대각합 (Trace)

$$ c = A_{ii} $$

```python
np.einsum("ii->", A)
```

### 내적 (Dot Product)

$$ c = a_{i} b_{i} $$

```python
np.einsum("i,i->", a, b)
```

### 외적 (Outer Product)

$$ C_{ij} = a_{i} b_{j} $$

```python
np.einsum("i,j->ij", a, b)
```

### 선형 변환 (Linear Transformation)

$$ c_{i} = A_{ij} b_{j} $$

```python
np.einsum("ij,j->i", A, b)
```

### 행렬곱 (Matrix Multiplication)

$$ C_{ik} = A_{ij} B_{jk} $$

```python
np.einsum("ij,jk->ik", A, B)
```

### 배치 행렬곱 (Batch Matrix Multiplication)

배치(batch)별로 행렬곱을 수행하는 연산이다. PyTorch의 `bmm` 함수로 수행할 수 있다.

$$ C_{bik} = A_{bij} B_{bjk} $$

```python
np.einsum("bij,bjk->bik", A, B)
```

### 이차형식 (Quadratic Form)

여기서 $A$는 정방행렬이어야 한다.

$$ b = x_{i} A_{ij} x_{j} $$

```python
np.einsum("i,ij,j->", x, A, x)
```

## 활용

`einsum`은 복잡한 연산을 간결하게 표현할 수 있다. `einsum`을 쓰지 않는다면 반복문을 사용하거나 내적, 행렬곱과 같은 연산을 조합해야 하는데, 아인슈타인 표기법에 비해 복잡할 수 있다. 그러나 `einsum`에 익숙하지 않은 사람의 입장에서는 오히려 가독성이 낮게 느껴질 수 있으므로 일장일단이 있다.

`einsum`은 적절히 사용 시 효율성이 좋다. 파이썬 자체의 계산 효율이 낮기 때문에, 파이썬에서 직접 반복문으로 아인슈타인 표기법을 직접 계산하는 것은 매우 효율이 떨어진다. 그러나 `einsum`은 NumPy 내부의 최적화된 연산을 사용하므로 훨씬 효율적이다.

반면 라이브러리에서 지원하는 연산의 경우 `einsum`으로 구현하는 것보다 더 효율적일 가능성이 매우 높다. 예를 들어, NumPy의 경우 내적, 행렬곱, 대각합(trace) 등의 연산을 지원하는데, 이들은 `einsum`으로도 구현할 수 있지만 제공되는 연산을 활용하는 것이 더 낫다. `einsum`은 상당히 보편적인 연산을 수행할 수 있으므로, 이에 따라 자연스럽게 오버헤드가 발생할 수밖에 없기 때문이다.

그러나 수행하고자 하는 연산이 이러한 기본 연산(내적, 행렬곱 등) 한 번이 아니라 여러 개의 조합으로 표현되는 경우 `einsum`이 더 효율적일 수 있다. 이러한 연산을 여러 번 조합할 경우, 계산 과정에 중간 결과물로써 생기는 텐서 인스턴스에 의해 오버헤드가 발생할 수 있다. `einsum`은 모든 연산 과정을 라이브러리 내부에서 하므로 이런 문제가 적을 것이다.

결론적으로, `einsum`으로 구현하기 좋은 연산은 내적, 행렬곱과 같은 기본 텐서 연산으로는 표현하기 어렵거나 복잡한 것들이다. 이 경우 `einsum`을 활용하면 코드를 간결하게 나타내고 효율적으로 계산할 수 있다. 이러한 연산은 특히 딥 러닝에서 높은 차원을 가진 텐서를 조작할 때 자주 사용된다.

## 참고문헌

- <https://en.wikipedia.org/wiki/Einstein_notation>
- <http://dslavsk.sites.luc.edu/courses/phys301/classnotes/einsteinsummationnotation.pdf>
- <https://rockt.github.io/2018/04/30/einsum>
